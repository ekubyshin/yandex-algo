package main

import (
	"bufio"
	"errors"
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"
)

//93250629
//cpu O(1) судя по условиям задачи, стэк не будет превышать 3, соответственно доступ к элементам O(1)
// Если учитывать разбитие строки по символам - то O(n), где n - кол-во операндов и операторов
//mem O(1) константа, тк доп память не требуется. Если, конечно возникнет ситуация,
// когда будут перечислены сначала все операнды, а потом кучей операторы, то стэк разрастется до O(n/2) что есть O(n)
// принцип работы: читается в буфер строка и разбивается на слова
// если это оператор, то определяется по таблице какой оператор вызывать
// если это не оператор, то значит операнд и кладется на стэк, до момента вызова оператора
// функция целочисленного деления определяется как округление по верхней границе деления дробей
// кажется, что можно оптимизировать работу и отказаться от приведения типо, дабы ускорить работу,
// тк с float операции в принципе занимают больше тактов, чем с инт, но это не является узким местом и можно принебречь

/*
Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.

Пример 1:
3 4 +
означает 3 + 4 и равно 7

Пример 2:
12 5 /
Так как деление целочисленное, то в результате получим 2.

Пример 3:
10 2 4 * -
означает 10 - 2 * 4 и равно 2

Разберём последний пример подробнее:

Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает, то есть перемножить эти два числа. В результате получим 8.

После этого выражение приобретёт вид:

10 8 -

Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

Для вычисления значения выражения, записанного в обратной польской нотации, нужно считывать выражение слева направо и придерживаться следующих шагов:

Обработка входного символа:
Если на вход подан операнд, он помещается на вершину стека.
Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений, взятых из стека в порядке добавления. Результат выполненной операции помещается на вершину стека.
Если входной набор символов обработан не полностью, перейти к шагу 1.
После полной обработки входного набора символов результат вычисления выражения находится в вершине стека. Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.
Замечание про отрицательные числа и деление: в этой задаче под делением понимается математическое целочисленное деление. Это значит, что округление всегда происходит вниз. А именно: если a / b = c, то b ⋅ c — это наибольшее число, которое не превосходит a и одновременно делится без остатка на b.

Например, -1 / 3 = -1. Будьте осторожны: в C++, Java и Go, например, деление чисел работает иначе.

В текущей задаче гарантируется, что деления на отрицательное число нет.

Формат ввода
В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции записаны через пробел.

На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.

Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

Формат вывода
Выведите единственное число — значение выражения.

Пример 1
Ввод	Вывод
2 1 + 3 *
9
Пример 2
Ввод	Вывод
7 2 + 4 * 2 +

*/

type Stack struct {
	data []int
}

func NewStack() Stack {
	return Stack{
		data: make([]int, 0, 10),
	}
}

func (s *Stack) Push(x int) {
	s.data = append(s.data, x)
}

func (s *Stack) Pop() (int, error) {
	if len(s.data) == 0 {
		return 0, errors.New("no elemets")
	}
	el := s.data[len(s.data)-1]
	s.data = s.data[:len(s.data)-1]
	return el, nil
}

func main() {
	reader := bufio.NewReader(os.Stdin)
	scanner := bufio.NewScanner(reader)
	scanner.Split(bufio.ScanLines)
	stack := NewStack()
	scanner.Scan()
	line := scanner.Text()
	vals := strings.Split(line, " ")
	for _, v := range vals {
		handleInput(string(v), &stack)
	}
	res, _ := stack.Pop()
	fmt.Println(res)
}

type calcAction func(int, int) int

var calcActions = map[string]calcAction{
	"-": minus,
	"+": plus,
	"*": mult,
	"/": div,
}

func determineAction(inp string) (*calcAction, error) {
	if act, ok := calcActions[inp]; ok {
		return &act, nil
	}
	return nil, errors.New("not found action")
}

func handleInput(inp string, stack *Stack) {
	act, err := determineAction(inp)
	if err != nil {
		if num, err := strconv.Atoi(inp); err == nil {
			stack.Push(num)
		}
		return
	}
	lst, _ := stack.Pop()
	prev, _ := stack.Pop()
	stack.Push((*act)(prev, lst))
}

func minus(a, b int) int {
	return a - b
}

func plus(a, b int) int {
	return a + b
}

func mult(a, b int) int {
	return a * b
}

func div(a, b int) int {
	return int(math.Floor(float64(a) / float64(b)))
}
