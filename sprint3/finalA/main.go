package main

/*
Задача
Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности (при этом массив все равно мог остаться отсортированным).
Тем не менее, нужно обеспечить возможность находить в нем элемент за O(logn).
Можно предполагать, что в массиве только уникальные элементы.
От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Обратите внимание, что считывать данные и выводить ответ не требуется.
Функция должна вернуть номер элемента массива, не изменяя сам массив.

Решение 105894604
CPU O(logn)
Mem O(1) - дополнительная память не требуется

По факту это тот же алгоритм бинарного поиска, только с проверкой границ left и right, чтобы элемент точно лежал в этих границах.
Возможные кейсы вхождения элемента в левой части
1. Если левая часть возрастает и элемент больше начала и меньше середины
2. Если левая часть убывает и элемент меньше начала и больше середины
Если элемент больше середины и меньше конца при этом левая часть не возрастает, то он в правой половине
В противном случаем, мы попадаем в кейс,  когда надо искать в левой части
*/

func brokenSearch(arr []int, k int) int {
	return binarySearch(arr, k, 0, len(arr))
}

func binarySearch(arr []int, target int, left int, right int) int {
	if right <= left {
		return -1
	}
	mid := (left + right) / 2
	if arr[mid] == target {
		return mid
	}
	if arr[left] < arr[mid] {
		if arr[left] <= target && target < arr[mid] {
			return binarySearch(arr, target, left, mid)
		}
		return binarySearch(arr, target, mid+1, right)
	}
	if arr[mid] < target && target <= arr[right-1] {
		return binarySearch(arr, target, mid+1, right)
	}
	return binarySearch(arr, target, left, mid)
}
