package main

/*
Задача
Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности (при этом массив все равно мог остаться отсортированным).
Тем не менее, нужно обеспечить возможность находить в нем элемент за O(logn).
Можно предполагать, что в массиве только уникальные элементы.
От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Обратите внимание, что считывать данные и выводить ответ не требуется.
Функция должна вернуть номер элемента массива, не изменяя сам массив.

Решение 106303438
CPU O(logn)
Mem O(1) - дополнительная память не требуется, slice указывается всегда на 1 массив

По факту это тот же алгоритм бинарного поиска, только с проверкой границ left и right, чтобы элемент точно лежал в этих границах.
Возможные кейсы вхождения элемента в левой части
1. Если левая часть возрастает и элемент больше начала и меньше середины
2. Если левая часть убывает и элемент меньше начала и больше середины
Если элемент больше середины и меньше конца при этом левая часть не возрастает, то он в правой половине
В противном случаем, мы попадаем в кейс,  когда надо искать в левой части
*/

func brokenSearch(arr []int, target int) int {
	left := 0
	right := len(arr)
	for left < right {
		mid := (left + right) / 2
		if arr[mid] == target {
			return mid
		}
		if arr[left] < arr[mid] {
			if arr[left] <= target && target < arr[mid] {
				right = mid
			} else {
				left = mid + 1
			}
			continue
		}
		if arr[mid] < target && target <= arr[right-1] {
			left = mid + 1
		} else {
			right = mid
		}
	}
	return -1
}
